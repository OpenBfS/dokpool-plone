(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "./.plone/++plone++static/components/patternslib/src/core/base.js":
/*!************************************************************************!*\
  !*** ./.plone/++plone++static/components/patternslib/src/core/base.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * A Base pattern for creating scoped patterns. It's similar to Backbone's\n * Model class. The advantage of this approach is that each instance of a\n * pattern has its own local scope (closure).\n *\n * A new instance is created for each DOM element on which a pattern applies.\n *\n * You can assign values, such as $el, to `this` for an instance and they\n * will remain unique to that instance.\n *\n * Older Patternslib patterns on the other hand have a single global scope for\n * all DOM elements.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\"),\n  __webpack_require__(/*! pat-registry */ \"./.plone/++plone++static/components/patternslib/src/core/registry.js\"),\n  __webpack_require__(/*! pat-mockup-parser */ \"./.plone/++plone++static/components/patternslib/src/core/mockup-parser.js\"),\n  __webpack_require__(/*! pat-logger */ \"./.plone/++plone++static/components/patternslib/src/core/logger.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function($, Registry, mockupParser, logger) {\n    \"use strict\";\n    var log = logger.getLogger(\"Patternslib Base\");\n\n    var initBasePattern = function initBasePattern($el, options, trigger) {\n        var name = this.prototype.name;\n        var log = logger.getLogger(\"pat.\" + name);\n        var pattern = $el.data(\"pattern-\" + name);\n        if (pattern === undefined && Registry.patterns[name]) {\n            try {\n                options = this.prototype.parser  === \"mockup\" ? mockupParser.getOptions($el, name, options) : options;\n                pattern = new Registry.patterns[name]($el, options, trigger);\n            } catch (e) {\n                log.error(\"Failed while initializing '\" + name + \"' pattern.\", e);\n            }\n            $el.data(\"pattern-\" + name, pattern);\n        }\n        return pattern;\n    };\n\n    var Base = function($el, options, trigger) {\n        this.$el = $el;\n        this.options = $.extend(true, {}, this.defaults || {}, options || {});\n        this.init($el, options, trigger);\n        this.emit(\"init\");\n    };\n\n    Base.prototype = {\n        constructor: Base,\n        on: function(eventName, eventCallback) {\n            this.$el.on(eventName + \".\" + this.name + \".patterns\", eventCallback);\n        },\n        emit: function(eventName, args) {\n            // args should be a list\n            if (args === undefined) {\n                args = [];\n            }\n            this.$el.trigger(eventName + \".\" + this.name + \".patterns\", args);\n        }\n    };\n\n    Base.extend = function(patternProps) {\n        /* Helper function to correctly set up the prototype chain for new patterns.\n        */\n        var parent = this;\n        var child;\n\n        // Check that the required configuration properties are given.\n        if (!patternProps) {\n            throw new Error(\"Pattern configuration properties required when calling Base.extend\");\n        }\n\n        // The constructor function for the new subclass is either defined by you\n        // (the \"constructor\" property in your `extend` definition), or defaulted\n        // by us to simply call the parent's constructor.\n        if (patternProps.hasOwnProperty(\"constructor\")) {\n            child = patternProps.constructor;\n        } else {\n            child = function() { parent.apply(this, arguments); };\n        }\n\n        // Allow patterns to be extended indefinitely\n        child.extend = Base.extend;\n\n        // Static properties required by the Patternslib registry \n        child.init = initBasePattern;\n        child.jquery_plugin = true;\n        child.trigger = patternProps.trigger;\n\n        // Set the prototype chain to inherit from `parent`, without calling\n        // `parent`'s constructor function.\n        var Surrogate = function() { this.constructor = child; };\n        Surrogate.prototype = parent.prototype;\n        child.prototype = new Surrogate();\n\n        // Add pattern's configuration properties (instance properties) to the subclass,\n        $.extend(true, child.prototype, patternProps);\n\n        // Set a convenience property in case the parent's prototype is needed\n        // later.\n        child.__super__ = parent.prototype;\n\n        // Register the pattern in the Patternslib registry.\n        if (!patternProps.name) {\n            log.warn(\"This pattern without a name attribute will not be registered!\");\n        } else if (!patternProps.trigger) {\n            log.warn(\"The pattern '\"+patternProps.name+\"' does not \" +\n                     \"have a trigger attribute, it will not be registered.\");\n        } else {\n            Registry.register(child, patternProps.name);\n        }\n        return child;\n    };\n    return Base;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./.plone/++plone++static/components/patternslib/src/core/base.js?");

/***/ }),

/***/ "./.plone/++plone++static/components/patternslib/src/core/mockup-parser.js":
/*!*********************************************************************************!*\
  !*** ./.plone/++plone++static/components/patternslib/src/core/mockup-parser.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n    __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function($) {\n    'use strict';\n\n    var parser = {\n        getOptions: function getOptions($el, patternName, options) {\n            /* This is the Mockup parser. An alternative parser for Patternslib\n             * patterns.\n             *\n             * NOTE: Use of the Mockup parser is discouraged and is added here for\n             * legacy support for the Plone Mockup project.\n             *\n             * It parses a DOM element for pattern configuration options.\n             */\n            options = options || {};\n            // get options from parent element first, stop if element tag name is 'body'\n            if ($el.length !== 0 && !$.nodeName($el[0], 'body')) {\n                options = getOptions($el.parent(), patternName, options);\n            }\n            // collect all options from element\n            var elOptions = {};\n            if ($el.length !== 0) {\n                elOptions = $el.data('pat-' + patternName);\n                if (elOptions) {\n                    // parse options if string\n                    if (typeof(elOptions) === 'string') {\n                        var tmpOptions = {};\n                        $.each(elOptions.split(';'),\n                            function(i, item) {\n                                item = item.split(':');\n                                item.reverse();\n                                var key = item.pop();\n                                key = key.replace(/^\\s+|\\s+$/g, '');    // trim\n                                item.reverse();\n                                var value = item.join(':');\n                                value = value.replace(/^\\s+|\\s+$/g, '');    // trim\n                                tmpOptions[key] = value;\n                            }\n                        );\n                        elOptions = tmpOptions;\n                    }\n                }\n            }\n            return $.extend(true, {}, options, elOptions);\n        }\n    };\n    return parser;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./.plone/++plone++static/components/patternslib/src/core/mockup-parser.js?");

/***/ }),

/***/ "./.plone/++resource++mockupjs/utils.js":
/*!**********************************************!*\
  !*** ./.plone/++resource++mockupjs/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\");\nvar $ = __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\");\n\n/* Pattern utils\n */\n\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function($) {\n  'use strict';\n\n  var QueryHelper = function(options) {\n    /* if pattern argument provided, it can implement the interface of:\n     *    - browsing: boolean if currently browsing\n     *    - currentPath: string of current path to apply to search if browsing\n     *    - basePath: default path to provide if no subpath used\n     */\n\n    var self = this;\n    var defaults = {\n      pattern: null, // must be passed in\n      vocabularyUrl: null,\n      searchParam: 'SearchableText', // query string param to pass to search url\n      pathOperator: 'plone.app.querystring.operation.string.path',\n      attributes: ['UID', 'Title', 'Description', 'getURL', 'portal_type'],\n      batchSize: 10, // number of results to retrive\n      baseCriteria: [],\n      sort_on: 'is_folderish',\n      sort_order: 'reverse',\n      pathDepth: 1\n    };\n    self.options = $.extend({}, defaults, options);\n\n    self.pattern = self.options.pattern;\n    if (self.pattern === undefined || self.pattern === null) {\n      self.pattern = {\n        browsing: false,\n        basePath: '/'\n      };\n    }\n\n    if (self.options.url && !self.options.vocabularyUrl) {\n      self.options.vocabularyUrl = self.options.url;\n    } else if (self.pattern.vocabularyUrl) {\n      self.options.vocabularyUrl = self.pattern.vocabularyUrl;\n    }\n    self.valid = Boolean(self.options.vocabularyUrl);\n\n    self.getBatch = function(page) {\n      return {\n        page: page ? page : 1,\n        size: self.options.batchSize\n      };\n    };\n\n    self.getCurrentPath = function() {\n      var pattern = self.pattern;\n      var currentPath;\n      /* If currentPath is set on the QueryHelper object, use that first.\n       * Then, check on the pattern.\n       * Finally, see if it is a function and call it if it is.\n       */\n      if (self.currentPath) {\n        currentPath = self.currentPath;\n      } else {\n        currentPath = pattern.currentPath;\n      }\n      if (typeof currentPath === 'function') {\n        currentPath = currentPath();\n      }\n      var path = currentPath;\n      if (!path) {\n        if (pattern.basePath) {\n          path = pattern.basePath;\n        } else if (pattern.options.basePath) {\n          path = pattern.options.basePath;\n        } else {\n          path = '/';\n        }\n      }\n      return path;\n    };\n\n    self.getCriterias = function(term, searchOptions) {\n      if (searchOptions === undefined) {\n        searchOptions = {};\n      }\n      searchOptions = $.extend({}, {\n        useBaseCriteria: true,\n        additionalCriterias: []\n      }, searchOptions);\n\n      var criterias = [];\n      if (searchOptions.useBaseCriteria) {\n        criterias = self.options.baseCriteria.slice(0);\n      }\n      if (term) {\n        term += '*';\n        criterias.push({\n          i: self.options.searchParam,\n          o: 'plone.app.querystring.operation.string.contains',\n          v: term\n        });\n      }\n      if (searchOptions.searchPath) {\n        criterias.push({\n          i: 'path',\n          o: self.options.pathOperator,\n          v: searchOptions.searchPath + '::' + self.options.pathDepth\n        });\n      } else if (self.pattern.browsing) {\n        criterias.push({\n          i: 'path',\n          o: self.options.pathOperator,\n          v: self.getCurrentPath() + '::' + self.options.pathDepth\n        });\n      }\n      criterias = criterias.concat(searchOptions.additionalCriterias);\n      return criterias;\n    };\n\n    self.getQueryData = function(term, page) {\n      var data = {\n        query: JSON.stringify({\n          criteria: self.getCriterias(term),\n          sort_on: self.options.sort_on,\n          sort_order: self.options.sort_order\n        }),\n        attributes: JSON.stringify(self.options.attributes)\n      };\n      if (page) {\n        data.batch = JSON.stringify(self.getBatch(page));\n      }\n      return data;\n    };\n\n    self.getUrl = function() {\n      var url = self.options.vocabularyUrl;\n      if (url.indexOf('?') === -1) {\n        url += '?';\n      } else {\n        url += '&';\n      }\n      return url + $.param(self.getQueryData());\n    };\n\n    self.selectAjax = function() {\n      return {\n        url: self.options.vocabularyUrl,\n        dataType: 'JSON',\n        quietMillis: 100,\n        data: function(term, page) {\n          return self.getQueryData(term, page);\n        },\n        results: function(data, page) {\n          var more = (page * 10) < data.total; // whether or not there are more results available\n          // notice we return the value of more so Select2 knows if more results can be loaded\n          return {\n            results: data.results,\n            more: more\n          };\n        }\n      };\n    };\n\n    self.search = function(term, operation, value, callback, useBaseCriteria, type) {\n      if (useBaseCriteria === undefined) {\n        useBaseCriteria = true;\n      }\n      if (type === undefined) {\n        type = 'GET';\n      }\n      var criteria = [];\n      if (useBaseCriteria) {\n        criteria = self.options.baseCriteria.slice(0);\n      }\n      criteria.push({\n        i: term,\n        o: operation,\n        v: value\n      });\n      var data = {\n        query: JSON.stringify({\n          criteria: criteria\n        }),\n        attributes: JSON.stringify(self.options.attributes)\n      };\n      $.ajax({\n        url: self.options.vocabularyUrl,\n        dataType: 'JSON',\n        data: data,\n        type: type,\n        success: callback\n      });\n    };\n\n    return self;\n  };\n\n  var Loading = function(options) {\n    /*\n     * Options:\n     *   backdrop(pattern): if you want to have the progress indicator work\n     *                      seamlessly with backdrop pattern\n     *   zIndex(integer or function): to override default z-index used\n     */\n    var self = this;\n    self.className = 'plone-loader';\n    var defaults = {\n      backdrop: null,\n      zIndex: 10005 // can be a function\n    };\n    if (!options) {\n      options = {};\n    }\n    self.options = $.extend({}, defaults, options);\n\n    self.init = function() {\n      self.$el = $('.' + self.className);\n      if (self.$el.length === 0) {\n        self.$el = $('<div><div></div></div>');\n        self.$el.addClass(self.className).hide().appendTo('body');\n      }\n    };\n\n    self.show = function(closable) {\n      self.init();\n      self.$el.show();\n      var zIndex = self.options.zIndex;\n      if (typeof(zIndex) === 'function') {\n        zIndex = Math.max(zIndex(), 10005);\n      } else {\n        // go through all modals and backdrops and make sure we have a higher\n        // z-index to use\n        zIndex = 10005;\n        $('.plone-modal-wrapper,.plone-modal-backdrop').each(function() {\n          zIndex = Math.max(zIndex, $(this).css('zIndex') || 10005);\n        });\n        zIndex += 1;\n      }\n      self.$el.css('zIndex', zIndex);\n\n      if (closable === undefined) {\n        closable = true;\n      }\n      if (self.options.backdrop) {\n        self.options.backdrop.closeOnClick = closable;\n        self.options.backdrop.closeOnEsc = closable;\n        self.options.backdrop.init();\n        self.options.backdrop.show();\n      }\n    };\n\n    self.hide = function() {\n      self.init();\n      self.$el.hide();\n    };\n\n    return self;\n  };\n\n  var getAuthenticator = function() {\n    var $el = $('input[name=\"_authenticator\"]');\n    if ($el.length === 0) {\n      $el = $('a[href*=\"_authenticator\"]');\n      if ($el.length > 0) {\n        return $el.attr('href').split('_authenticator=')[1];\n      }\n      return '';\n    } else {\n      return $el.val();\n    }\n  };\n\n  var generateId = function(prefix) {\n    if (prefix === undefined) {\n      prefix = 'id';\n    }\n    return prefix + (Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16).substring(1));\n  };\n\n  var setId = function($el, prefix) {\n    if (prefix === undefined) {\n      prefix = 'id';\n    }\n    var id = $el.attr('id');\n    if (id === undefined) {\n      id = generateId(prefix);\n    } else {\n      /* hopefully we don't screw anything up here... changing the id\n       * in some cases so we get a decent selector */\n      id = id.replace(/\\./g, '-');\n    }\n    $el.attr('id', id);\n    return id;\n  };\n\n  var getWindow = function() {\n    var win = window;\n    if (win.parent !== window) {\n      win = win.parent;\n    }\n    return win;\n  };\n\n  var parseBodyTag = function(txt) {\n    return $((/<body[^>]*>[^]*<\\/body>/im).exec(txt)[0]\n      .replace('<body', '<div').replace('</body>', '</div>')).eq(0).html();\n  };\n\n  var featureSupport = {\n    /* Well tested feature support for things we use in mockup.\n     * All gathered from: http://diveintohtml5.info/everything.html\n     * Alternative to using some form of modernizr.\n     */\n    dragAndDrop: function() {\n      return 'draggable' in document.createElement('span');\n    },\n    fileApi: function() {\n      return typeof FileReader != 'undefined'; // jshint ignore:line\n    },\n    history: function() {\n      return !!(window.history && window.history.pushState);\n    }\n  };\n\n  var bool = function(val) {\n    if (typeof val === 'string') {\n      val = $.trim(val).toLowerCase();\n    }\n    return ['false', false, '0', 0, '', undefined, null].indexOf(val) === -1;\n  };\n\n  var escapeHTML = function(val) {\n    return $('<div/>').text(val).html();\n  };\n\n  var removeHTML = function(val) {\n    return val.replace(/<[^>]+>/ig, '');\n  };\n\n  var storage = {\n    // Simple local storage wrapper, which doesn't break down if it's not available.\n    get: function (name) {\n        if (window.localStorage) {\n          var val = window.localStorage[name];\n          return typeof(val) === 'string' ? JSON.parse(val) : undefined;\n      }\n    },\n\n    set: function (name, val) {\n      if (window.localStorage) {\n        window.localStorage[name] = JSON.stringify(val);\n      }\n    }\n  };\n\n  return {\n    bool: bool,\n    escapeHTML: escapeHTML,\n    removeHTML: removeHTML,\n    featureSupport: featureSupport,\n    generateId: generateId,\n    getAuthenticator: getAuthenticator,\n    getWindow: getWindow,\n    Loading: Loading,\n    loading: new Loading(),  // provide default loader\n    parseBodyTag: parseBodyTag,\n    QueryHelper: QueryHelper,\n    setId: setId,\n    storage: storage\n  };\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n\n//# sourceURL=webpack:///./.plone/++resource++mockupjs/utils.js?");

/***/ })

}]);